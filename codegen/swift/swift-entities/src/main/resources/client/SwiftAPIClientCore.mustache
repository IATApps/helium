import Foundation

enum Result<S, E> {
    case Success(S)
    case Failure(E)
}

struct Request {
    var url: URL
    var method: RequestMethod
    var params: [String: AnyObject]
    var encoding: RequestParametersEncoding
    var expectedStatusCodes: Range<Int>
    var expectedContentTypes: [String]
    var headers: [String: String]

    init(
        url: URL,
        method: RequestMethod,
        encoding: RequestParametersEncoding,
        params: [String: AnyObject] = [:],
        headers: [String: String] = [:],
        expectedStatusCodes: Range<Int> = 200..<300,
        expectedContentTypes: [String] = ["*/*"]
        ) {
        self.url = url
        self.method = method
        self.params = params
        self.encoding = encoding
        self.expectedStatusCodes = expectedStatusCodes
        self.expectedContentTypes = expectedContentTypes
        self.headers = headers
    }
}

// MARK:- Request Params Encoding

enum RequestParametersEncoding {
    case JSON   // application JSON
    case URL    // parameters in URL
    case FORM   // parameters in BODY form-encoded
}

// MARK:- Request Method

enum RequestMethod: String {
    case GET
    case POST
    case PUT
    case DELETE
    case PATCH
}

// MARK:- Request Provider

typealias RequestProvider = () -> (Request)


// MARK:- Response

struct APIResponse<T> {
    let value: T
    let response: HTTPURLResponse?

    init(value: T, response: HTTPURLResponse? = nil) {
        self.value = value
        self.response = response
    }
}

// MARK:- Response Error

struct APIResponseError<E>: Error {
    let error: E
    let response: HTTPURLResponse?

    init(error: E, response: HTTPURLResponse? = nil) {
        self.error = error
        self.response = response
    }
}

// MARK:- Cancellable

protocol Cancellable {
    func cancel()
}

// MARK:- Gateway

protocol Gateway {
    func requestWithCallback<T>(
        responseTransformer: @escaping (NSData?) -> Result<T, NSError>,
        callback: @escaping (Result<APIResponse<T>, APIResponseError<NSError>>) -> Void
    ) -> Cancellable
}

extension Gateway {
    func request<T>(
        responseTransformer: @escaping (NSData?) -> Result<T, NSError>,
        success: ((APIResponse<T>) -> Void)?,
        failure: ((APIResponseError<NSError>) -> Void)?
    ) -> Cancellable {
        return requestWithCallback(responseTransformer: responseTransformer) { (result:Result<APIResponse<T>, APIResponseError<NSError>>) in
            switch result {
            case .Success(let response): success?(response)
            case .Failure(let responseError): failure?(responseError)
            }
        }
    }
}


// MARK:- Network API Service Request Callback

typealias APIServiceRequestCallback = (Result<APIResponse<NSData?>, APIResponseError<NSError>>) -> Void

// MARK:- Protocol

protocol APIService {
    func request(request: Request, callback: @escaping APIServiceRequestCallback) -> Cancellable
}

class GatewayImpl: Gateway {

    private let apiService: APIService
    private let requestProvider: RequestProvider

    init(apiService: APIService,
         requestProvider: @escaping RequestProvider
        ) {
        self.apiService = apiService
        self.requestProvider = requestProvider
    }

    internal func requestWithCallback<T>(
        responseTransformer: @escaping (NSData?) -> Result<T, NSError>,
        callback: @escaping (Result<APIResponse<T>, APIResponseError<NSError>>) -> Void
    ) -> Cancellable {
        return apiService.request(request: requestProvider(), callback: { result in
            switch result {
            case .Success(let response):
                let responseTransformerResult = responseTransformer(response.value)
                switch responseTransformerResult {
                case .Success(let transformedResponse):
                    callback(.Success(APIResponse(value: transformedResponse, response: response.response)))
                case .Failure(let error):
                    callback(.Failure(APIResponseError(error: error, response: response.response)))
                }

            case .Failure(let responseError):
                callback(.Failure(responseError))
            }

        })
    }

}

